# Awesome Task Exchange System (aTES) для UberPopug Inc

oreshka.net@gmail.com

## Используемые технологии

**Kafka** - сервис очередей

**Redis** - организация кэширования и хранения токенов авторизации

**Postgress** - базы данных сервисов

**ClickHouse** - аналитическая база данных

**Go** - язык разработки сервисов

**Docker** - контейнеризация сервисов

## UI и авторизация

**UI** - сервис, в котором реализована все варианты дашбордов, а так же форма авторизации. Сервис кэширует в Redis данные пользователя и токены авторизации. Для получения данных и обработки действий пользователя сервис обращается к back-сервисам.

**CACHE** - база данных Redis.

**USERS** - сервис, реализующий API для работы с пользователями: получение данных пользователя и его ролей. У сервиса есть база данных (postgres).

## Таск-трекер

**BACK_TASKS** - бэкенд-сервис, реализующий HTTP-API для работы с задачами: создание, изменение, выполнение, назначение задач. Запросы на получение данных синхронные и обращаются к сервису **TASKS**.

Создание, изменение, назначение, завершение - асинхронные запросы, которые постятся в очереди Kafka:

- TASK.CREATE - создана новая задача
- TASK.MODIFY - изменена нзадача
- TASK.REASSIGN - запрос на переассайна задач
- TASK.FINISH - задача выполнена

**TASKS** - сервис, выполняющий бизнес-логику таск-трекера. Подписывается на сообщения в очередях Kafka и выполняет их обработку. Задачи хранятся в БД TASKS (postgres).

Результат обработки некоторых событий публикуется в виде сообщений в kafka:

- TASK.CREATE → TASK.CREATED - задача записана в таск-трекере
- TASK.MODIFY → TASK.ASSIGNED - задача переназначена другому пользователю
- TASK.REASSIGN → TASK.ASSIGNED - для каждой задачи публикуется сообщение ассайна (запрос переназначения задач).

## Аккаунтинг

**BACK_ACCOUNTING** - бэкенд-сервис, реализующий API для работы с аккаунтами пользователей: получение баланса, аудит лога.

**JOBBER** - сервис, выполняющий по расписанию определённые действия: постит в очереди Kafka различные события. Сейчас событие только одно - закрытие дня в аккаунтинге. Но в перспективе могут быть и другие события (например, создание повторяющихся задач или начисление ежемесячных премий сотрудникам).

**ACCOUNTING** - сервис, выполняющий бизнес-логику аккаунтинга. Подписывается на сообщения таск-трекера и джоббера:

- TASK.CREATED - в таск-трекере создана задача и её нужно расценить.
- TASK.ASSIGNED - в таск-трекере задача назначена на определённого пользователя (или переназначена), а значит нужно списать определённую сумму и результат запостить в очередь BALANCE.DECREASE.
- TASK.FINISH - получена информация, что задача выполнена, а значит нужно начислить пользователю стоимость задачи и результат запостить в очередь BALANCE.INCREASE. А ещё информация о закрытии задачи вместе с её стоимостью постится в очередь TASK.CLOSED
! Возможно, стоило сделать ещё одну очередь TASK.FINISHED и обрабатывать только задачи, которые обработаны таск-системой. Но, пока не вижу в этом необходимости.
- ACCOUNTING.CLOSE_DATE - получена команда на закрытие дня. А значит нужно “подбить итоги” и рассчитать балансы всех пользователей, а результат запостить в очередь BALANCE.PAYMENT

**AUDIT_LOG** - сервис, организующий возможность получения аудит лога. Слушает сообщения BALANCE.* и записывает все в базу данных ACCOUNTING.

**PAYMENTS** - сервис слушает очередь BALANCE.PAYMENT и по сообщениям перечисляет деньги пользователям.  

**SENDER** - сервис доставки e-mail сообщений пользователю из сообщений очереди BALANCE.PAYMENT.

## Аналитика

**BACK_ANALYTICS** - бэкенд-сервис, реализующий API предоставления данных для различных аналитических запросов.

**ANALYTINCS** - сервис, организующий сбор и хранение аналитических показателей, агрегацию и выборку по запросу сервиса BACK_ANALYTICS. Сервис подписывается на очереди:

- TASK.CLOSED - сбор информации о закрытых задачах
- BALANCE.* - сбор информации о всех изменениях баланса пользователя.

Все данные хранятся в базе ClickHouse. Этот движок позволяет компактно хранить данные, а так же агрегировать данные в различных разрезах.

## Вопросы

- Никак не отразил в архитектуре логирование, в том числе трассировку запросов. Можно реализовать через очереди с отдельным сервисом логирования. Для любого события в системе создаётся trace_id, который прокидывается во все запросы и сообщения.
- Не продуманы коллбеки с результатами асинхронных событий. Но вроде-как сам интерфейс не подразумевает такое взаимодействие с пользователем.